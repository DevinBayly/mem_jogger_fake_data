{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../IndividualVis.svelte",
    "../../Map.svelte",
    "../../Popout.svelte",
    "../../UAHeader.svelte",
    "../../VisOption.svelte",
    "../../backButton.svelte",
    "../../brushableIndividual.svelte",
    "../../dropdown.svelte",
    "../../map_vis.svelte"
  ],
  "sourcesContent": [
    "<script>\n  // change to cause build.\n  import UAHeader from \"./UAHeader.svelte\";\n  import NotPermitted from \"./NotPermitted.svelte\";\n  import IV from \"./IndividualVis.svelte\";\n  import {assignThreshold} from \"./algos.js\"\n  import { onMount } from \"svelte\";\n  import { wifiData } from \"./store.js\";\n  let auth, signInButton, signInHolder, introText;\n  //Teresa Portela's auth functions\n  function loadData() {\n        //remove the removable elements\n        for (let e of document.querySelectorAll(\".removable\")) {\n          e.remove();\n        }\n        console.log(\"Sign in success\");\n        signInButton.style.color = \"white\";\n        signInHolder.style.position = \"absolute\";\n        signInHolder.style.right = \"10px\";\n        signInHolder.style.top = \"20px\";\n        signInHolder.style.margin = \"0px\";\n        // converted fetch from ajax code\n        fetch(\"my_fake_data_1606869759.json\")\n          .then(res => res.json())\n          .then(jsonData => {\n            // load the individual visualizations at this point\n            //remove everything except the signout\n            // properly format data for vis\n            // issue with data being string still? this seems intermittent,\n            if (typeof \"\" === typeof jsonData) {\n              jsonData = JSON.parse(jsonData);\n            }\n            console.log(\"json data is \", jsonData);\n            console.log(\"type of json data \", typeof jsonData);\n            jsonData = jsonData.map(e => {\n              return e;\n            });\n            // bump up the times less than 5 mins\n            assignThreshold(jsonData)\n            new IV({\n              target: document.body,\n              props: {\n                reportData: jsonData\n              }\n            });\n            wifiData.set(jsonData);\n          })\n          .catch(e => {\n            console.log(\"error\", e);\n            //remove the removable elements\n            for (let e of document.querySelectorAll(\".removable\")) {\n              e.remove();\n            }\n            // load the missing data page\n            new NotPermitted({\n              target: document.body,\n              props: {\n                reason: \"nodata\"\n              }\n            });\n          });\n      }\n  function userButton(auth) {\n    var state = signInButton.innerHTML;\n    if (state === \"Sign Out\") {\n      signInButton.innerHTML = \"Sign In\";\n      // enssssure that we set up the auth page again\n      // prevent auto loading the map\n\n      document.cookie = \"gotovis=false\";\n      //replace the history to remove the access token even on back\n      if (document.querySelector(\"#secondVisHolder\")) {\n        document.querySelector(\"#secondVisHolder\").remove();\n      }\n      if (document.querySelector(\"#holder\")) {\n        document.querySelector(\"#holder\").remove();\n      }\n      if (document.querySelector(\"#signin\")) {\ndocument.querySelector(\"#signin\").remove()\n      }\n      let newURl = `${window.location}`;\n      window.history.replaceState({}, \"\", newURl.replace(/index.*/, \"\"));\n      new NotPermitted({\n        target: document.body,\n        props: {\n          reason: \"user is signed out, close Tab or reload page.\"\n        }\n      });\n      //add a notpermitted page with the reason \"you are logged out\"\n    } else {\n      signInButton.innerHTML = \"Sign Out\";\n      loadData()\n    }\n  }\n\n\n  onMount(() => {\n    signInButton.addEventListener(\"click\", () => {\n      userButton();\n    });\n  });\n</script>\n\n<style>\n  #small {\n    font-size: 12px;\n  }\n  #title {\n    margin: 10%;\n  }\n  #summary {\n    width: 80%;\n    margin: 0 auto;\n  }\n  #signin {\n    margin: 5%;\n  }\n</style>\n\n<UAHeader />\n<div bind:this={introText} class=\"removable\">\n  <div id=\"Title\">\n    <h1>UA Timescape</h1>\n  </div>\n  <div id=\"summary\">\n    <p>\n      Minimizing exposure to the novel coronavirus is key to protecting UArizona\n      students, faculty and staff from COVID-19. This site has been created to\n      support strategic efforts related to crowd density, managing campus\n      spaces, mitigating spread, and learning about risk factors.\n    </p>\n    <p>You will need authorization to log in to this site using your NetID.</p>\n  </div>\n\n</div>\n<div id=\"signin\" bind:this={signInHolder}>\n  <a bind:this={signInButton}>Sign In</a>\n</div>\n<div id=\"contact\" class=\"removable\">\n  <p id=\"small\">For questions, please contact: uacap@list.arizona.edu</p>\n</div>\n",
    "<script>\n  export let reportData;\n  import VisOp from \"./VisOption.svelte\";\n  import { onMount } from \"svelte\";\n  import MapApplication from \"./map_vis.svelte\";\n  // put in Teresa's signin code\n  // include the reachout to the lambda function\n  // introduce the page with the options\n  let holder;\n  let map = () => {\n    for (let opHolder of document.querySelectorAll(\"#holder\")) {\n      opHolder.remove();\n    }\n    console.log(\"loading map\");\n    // remove holder\n    new MapApplication({\n      target: document.body\n    });\n  };\n  onMount(() => {\n    // look for the gotovis ccookie, and launch map automatically if found\n    let cookies = decodeURIComponent(document.cookie);\n    cookies.split(\";\").map(e => {\n      console.log(\"searching cookies\", e);\n      if (e.match(/gotovis=true/)) {\n        // remove the cookie\n        document.cookie = \"gotovis=false\";\n        // launch the map\n        map();\n      }\n    });\n  });\n</script>\n\n<style>\n  * {\n    z-index: 5;\n  }\n  #holder {\n    height: 100%;\n    background: white;\n  }\n  #title {\n    display: flex;\n    justify-content: center;\n  }\n  #options {\n    display: flex;\n    justify-content: center;\n  }\n  #subIntro p {\n    width: 80%;\n    margin: 0 auto;\n    padding-bottom: 20px;\n  }\n  #horizontal {\n    padding-top: 5px;\n    display: flex;\n    align-items: stretch;\n    height: 100%;\n  }\n  #lhs {\n    flex: 1 1;\n    background: #ededed;\n    border-radius: 10px;\n    box-shadow: 0 7px 23px 0 rgba(32, 44, 62, 0.68);\n    margin-right: 5px;\n  }\n  #rhs {\n    flex: 3 3;\n  }\n  #introItalic {\n    font-style: italic;\n    font-size: 12px;\n    color: #828181;\n  }\n  #lhsHeader {\n    padding-top: 20%;\n  }\nul.basic {\nall:unset;\n}\n.basic li {\n  all:unset;\n  display:list-item;\n  list-style: circle black;\n}\nli a {\n  all:unset;\n  color:blue;\n  cursor:pointer;\n}\n.sublhs {\n  display:flex;\n  padding-left:20%;\n}\n.sublhs p {\n  cursor:pointer;\n}\n</style>\n\n<div id=\"holder\" bind:this={holder}>\n  <div id=\"horizontal\">\n    <div id=\"lhs\">\n      <div id=\"lhsHeader\" class=\"sublhs\">\n        <p id=\"lhsHeader\">\n          <b>Memory Map Help</b>\n        </p>\n      </div>\n\n      <div id=\"about\" class=\"sublhs\">\n        <ul class=\"basic\">\n          <li>\n\n            <p\n              href=\"#\"\n              title=\" This Memory Jog map is designed to help you remember where\n              you’ve been on the UA campus for the two weeks prior to your\n              survey. Please understand that the displayed locations and other\n              data is a “best guess”, based on UA wifi connection information\n              from your internet-enabled devices, such as a smart watch, or\n              mobile phone. The connection information can be ambiguous, and\n              vary widely from one smart device to another. This tool is only to\n              help jog your memory, and is not guaranteed to be completely\n              accurate.This Memory Jog map is designed to help you remember\n              where you’ve been on the UA campus for the two weeks prior to your\n              survey. Please understand that the displayed locations and other\n              data is a “best guess”, based on UA wifi connection information\n              from your internet-enabled devices, such as a smart watch, or\n              mobile phone. The connection information can be ambiguous, and\n              vary widely from one smart device to another. This tool is only to\n              help jog your memory, and is not guaranteed to be completely\n              accurate. \">\n              About this tool\n            </p>\n          </li>\n        </ul>\n      </div>\n\n      <div id=\"screencast\" class=\"sublhs\">\n        <ul class=\"basic\">\n          <li>\n            <a href=\"instructions.webm\">How-to use (video)</a>\n          </li>\n        </ul>\n      </div>\n    </div>\n    <div id=\"rhs\">\n      <div id=\"title\">\n        <h3>Memory Jogger</h3>\n      </div>\n      <div id=\"subIntro\">\n        <p id=\"introItalic\">\n          Note: this tool is only intended to help Jog your memory. The\n          displayed locations are a \"best guess,\" and aren't guaranteed to be\n          completely accurate.\n        </p>\n      </div>\n      <div id=\"options\">\n        <div id=\"map-side\" on:click={map}>\n          <VisOp\n            imgSrc=\"map_background_updated.png\"\n            summaryText=\"Click the image to explore where you've been on campus\n            for over 15 minutes at a time overlaid on this campus map\" />\n        </div>\n      </div>\n    </div>\n  </div>\n\n</div>\n",
    "<script>\n  //\n  export let buildingJSON;\n  import Popout from \"./Popout.svelte\"\n  import { MergeInterval } from \"./algos.js\";\n  import { onMount } from \"svelte\";\n  import { wifiData , timeRange} from \"./store.js\";\n  import * as d3 from \"d3\";\n  import legend from \"d3-svg-legend\";\n  // make a 4 minute cookie that can take them back to the visualization page if they refresh\n  let future = new Date()\n  future.setMinutes(future.getMinutes() + 4)\n  document.cookie=`gotovis=true;expires=${JSON.stringify(future)}`\n  onMount(async () => {\n    console.log(\"loaded\");\n    console.log(\"building Json is \", buildingJSON);\n    let mymap = L.map(\"mapid\").setView([32.231481, -110.951838], 18);\n    L.esri.basemapLayer(\"Gray\").addTo(mymap);\n    var subtleUA = L.esri\n      .tiledMapLayer({\n        url:\n          \"https://services.maps.arizona.edu/pdc/rest/services/SubtleCanvasTiles/MapServer\"\n      })\n      .addTo(mymap);\n    // this  is the magic line for converting the polygon data into useful values\n    /*\n      let point = new L.Point(centerL20[0],centerL20[1])\n      let pointLatLng = L.Projection.SphericalMercator.unproject(point)\n      */\n    // TODO think about preconfiguring the buildingJSON to be a map already just with coordinates and building numbers\n    let buildingMap = {};\n    for (let feature of buildingJSON.features) {\n      // recall that the coordinates are ordered x,y in geojson, so must put into conversion correctly\n      buildingMap[\n        feature.properties[\"Buildings.SpaceNumLetter\"]\n      ] = new L.LatLng(\n        feature.geometry.coordinates[1],\n        feature.geometry.coordinates[0]\n      );\n    }\n    console.log(\"building map is \", buildingMap);\n\n    // subscribe to the store\n    let once = false;\n    let graphData,\n      circleScale,\n      catScale,\n      applyLatLngToLayer,\n      bboxNWLatLng,\n      legendSvg,\n      legendG,\n      legendEle,\n      bboxSELatLng,\n      svg,\n      maxRadius = 20,\n      g;\n    let redraw = function() {\n      // need a function to calculate the bounds of the points\n      console.log(\"redrawing\");\n      // occasionally when zooming and panning the svg's container move, so we have to set svg to be relative and move it left and right\n\n      // make a circle and append it to the svg, and then transform it with the results of the applylatlng\n      let circle = g\n        .selectAll(\".testPoints\")\n        .data(graphData, d => d.number)\n        .join(\n          enter =>\n            enter\n              .append(\"circle\")\n              .attr(\"opacity\",.8)\n              .attr(\"r\", 10)\n              .attr(\"stroke\",\"black\")\n              .attr(\"stroke-width\",1)\n              .attr(\"class\", \"testPoints\")\n              .attr(\"transform\", d => {\n                if (d.coords == undefined) {\n                  console.log(\"missing coords on\", d);\n                } else {\n                  return `translate(${applyLatLngToLayer(d.coords).x},${\n                    applyLatLngToLayer(d.coords).y\n                  })`;\n                }\n              })\n              .attr(\"fill\", d => catScale(d.category))\n              .attr(\"title\", d => {\n                if (d.duration > 60) {\n                  return `${Math.floor(d.duration / 60)} Hours, ${d.duration% 60} Minutes`;\n                } else {\n                  return `${d.duration} Minutes`;\n                }\n              }),\n          update =>\n            update\n              .attr(\"transform\", d => {\n                if (d.coords == undefined) {\n                  console.log(\"missing coords on\", d);\n                } else {\n                  return `translate(${applyLatLngToLayer(d.coords).x},${\n                    applyLatLngToLayer(d.coords).y\n                  })`;\n                }\n              })\n              .attr(\"fill\", d => catScale(d.category))\n              .attr(\"title\", d => {\n                if (d.duration > 60) {\n                  return `${Math.floor(d.duration / 60)} Hours, ${d.duration% 60} Minutes`;\n                } else {\n                  return `${d.duration} Minutes`;\n                }\n              }),\n          exit => exit.remove()\n        );\n      circle.on(\"mouseover\",function(){\n        let circ = d3.select(this)\n        let data = circ.data()[0]\n        //get the xy, and make a new popout, push the popout to collection to remove on zoom\n        let duration = (data.duration > 60) ? `${Math.floor(data.duration / 60)} Hours, ${(data.duration% 60).toPrecision(2)} Minutes`: `${data.duration.toPrecision(2)} Minutes`\n        new Popout({\n          target:mymap.getPanes().overlayPane,\n          props:{\n            time:duration,\n            screen:applyLatLngToLayer(data.coords)\n          }\n        })\n      })\n      circle.on(\"mouseout\",()=> {\n        for (let popout of document.querySelectorAll(\"#popoutHolder\")) {\n          popout.remove()\n        }\n      })\n      // the width is the diff nw and se bbox points\n      let screenNW = applyLatLngToLayer(bboxNWLatLng);\n      let screenSE = applyLatLngToLayer(bboxSELatLng);\n      // make sure the circles don't get cut off, so we add a radius on all edges of SVG\n      svg.attr(\"width\", screenSE.x - screenNW.x + 2 * maxRadius);\n      svg.attr(\"height\", screenSE.y - screenNW.y + 2 * maxRadius);\n      // get the pixel coordinates of the top left corner of bbox\n      // subtract some left so we don't cutt off the circles\n      svg.style(\"left\", screenNW.x - maxRadius + \"px\");\n      svg.style(\"top\", screenNW.y - maxRadius + \"px\");\n      // now update the g that is containing the circles\n      // add in the circle radius because points need to shift extra given the padded space\n      g.attr(\n        \"transform\",\n        `translate(${-screenNW.x + maxRadius},${-screenNW.y + maxRadius})`\n      );\n    };\n    let updateData = userData => {\n      //\n      console.log(\"running data\");\n      document.querySelector(\"#legendInfo\").innerHTML = \"Estimated Minutes Spent in Area\";\n      if (userData.length == 0 || window.doIt==true) {\n        // just pick a graphData\n        // remove the legend\n        if (legendG != undefined){\n          legendG.remove();\n        }\n        document.querySelector(\"#legendInfo\").innerHTML = \"No data found for this time interval, drag to select a different one.\";\n        graphData = [];\n        redraw();\n        return;\n      }\n      let activeBuildings = {};\n      for (let connection of userData) {\n        if (activeBuildings[connection.apBuildingNumber] == undefined) {\n          activeBuildings[connection.apBuildingNumber] = {\n            coords: buildingMap[connection.apBuildingNumber],\n            connections: [connectionData(connection)],\n            number: connection.apBuildingNumber\n          };\n        } else {\n          activeBuildings[connection.apBuildingNumber].connections.push(\n            connectionData(connection)\n          );\n        }\n      }\n      // feed each building's connections into the mergeinterval algorithm, sum and set as duration value\n      graphData = [];\n      for (let building in activeBuildings) {\n        // run the mergeinterval algorithm\n        let dedupDurations = MergeInterval(\n          activeBuildings[building].connections\n        );\n        let sum = 0;\n        // calculate sum in ms\n        for (let connection of dedupDurations) {\n          sum += connection.dur;\n        }\n        let minutes = sum / (1000 * 60);\n        //establish a duration attribute in minutes\n        activeBuildings[building].duration = minutes;\n        let category;\n        if (minutes < 15) {\n          category = 1;\n        } else if (minutes > 15 && minutes < 60) {\n          category = 2;\n        } else {\n          category = 3;\n        }\n\n        activeBuildings[building].category = category;\n        graphData.push(activeBuildings[building]);\n      }\n      //get only the durations and establish domain\n      // only update the domain once\n      let durations = graphData.map(e => e.duration);\n      // create categorical scale\n      catScale = d3.scaleQuantize().domain([1,3]).range([\"#fee8c8\",\"#fdbb84\",\"#e34a33\"]);\n\n      let minCircleScale = d3\n        .scaleLinear()\n        .domain([0, Math.max(...durations)])\n        .range([0, 20]);\n      circleScale\n        .domain([minCircleScale.invert(5), Math.max(...durations)])\n        .range([5, 20]);\n      createLegend();\n      // filter out the missing coordinate buildings\n      graphData = graphData.filter(building=> building.coords!=undefined)\n      // update legend so values change\n      console.log(\"graph data \", graphData);\n      // calculate the nw corner of a bounding box on the points\n      let bbox = { x: {min:-110.970542,max:-110.933505}, y: {min:32.223594,max:32.246132} };\n      // calculate the bounding box on the circles that are being drawn, decide on a max radius, and use it\n      for (let i = 0; i < graphData.length; i++) {\n        let d = graphData[i].coords;\n        console.log('using ',d)\n        if (d == undefined) {\n          console.log(\"missing coords\", d);\n\n          continue;\n        }\n        if (d.lat > bbox.y.max) {\n          bbox.y.max = d.lat;\n        }\n        if (d.lat < bbox.y.min) {\n          bbox.y.min = d.lat;\n        }\n        if (d.lng > bbox.x.max) {\n          bbox.x.max = d.lng;\n        }\n        if (d.lng < bbox.x.min) {\n          bbox.x.min = d.lng;\n        }\n      }\n      // the northwest corner is the max.y and the min.x, and the south east corner is the min.y and the max.x\n      console.log(\"boundsbox is\", bbox);\n      bboxNWLatLng = new L.LatLng(bbox.y.max, bbox.x.min);\n      bboxSELatLng = new L.LatLng(bbox.y.min, bbox.x.max);\n      redraw();\n    };\n    // this function takes the important values out of each connection and makes an object that can be put in an array for mergeinterval algorithm to run on\n    // first step in deduplicating duration calculations\n    let connectionData = d => {\n      // calculate in ms the data in niceDuration\n      let parts = d.niceDuration.split(\":\").map(e => parseInt(e));\n      // hour,minute,second, want in ms as that's the getTime resolution\n      let totalDuration =\n        (parts[0] * 60 * 60 + parts[1] * 60 + parts[2]) * 1000;\n      // 15minutes in ms\n      if (totalDuration < 15 * 60 * 1000) {\n        //console.error(\"duration is less than 15 mins for \", d);\n      }\n      return { start: d._time, dur: totalDuration };\n    };\n    let initialize = userData => {\n      // this is the width the svg should be to cover the full map\n      let bounds = mymap.getPixelBounds();\n      let width = bounds.max.x - bounds.min.x;\n      let height = bounds.max.y - bounds.min.y;\n      // create an svg\n      svg = d3.select(mymap.getPanes().overlayPane).append(\"svg\");\n      g = svg.append(\"g\").attr(\"class\", \"leaflet-zoom-hide\");\n      // define apply latlng to layer that takes in geopoints and produces screenspace x,y for drawing on svg\n      // NOTE that geojson points are going to have the x first in the coordinates\n      applyLatLngToLayer = function(d) {\n        // d is a lat lng calculated from the getCenter() method of a polyline\n        // do some comparison of building number to geojson of buildings to get coords\n        return mymap.latLngToLayerPoint(d);\n      };\n      // connect redraw to the map events\n      mymap.on(\"zoomend\", redraw);\n      mymap.on(\"moveend\", redraw);\n      //establish the circle scale before the data gets changed at all\n      // decide circle scale is the sum of the amount of time spent in that location during the selected time\n      // separate by building\n      circleScale = d3\n        .scaleLinear()\n        .nice()\n        .range([5, 20])\n        .clamp(true);\n      //legend setup\n    };\n    let createLegend = () => {\n      if (legendG != undefined) {\n        legendG.remove();\n      }\n      legendSvg = d3.select(\"#legend\");\n      legendG = legendSvg.append(\"g\").attr(\"transform\", \"translate(20,20)\");\n      legendEle = legend\n        .legendColor()\n        .scale(catScale)\n        .labels([\"< 15 mins\",\"15 mins to 1 hour \", \"> 1 hour\"])\n        .shape(\"circle\")\n        .labelOffset(20)\n        .shapePadding(20)\n        .orient(\"vertical\");\n      legendG.call(legendEle);\n      d3.select(\"#legendHolder\").style(\n        \"width\",\n        legendG.node().getBoundingClientRect().width + 20 + \"px\"\n      );\n      legendSvg.attr(\n        \"height\",\n        legendG.node().getBoundingClientRect().height + 20 + \"px\"\n      );\n      legendSvg.attr(\n        \"width\",\n        legendG.node().getBoundingClientRect().width + 20 + \"px\"\n      );\n      d3.selectAll(\".swatch\").attr(\"stroke\",\"black\").attr(\"stroke-width\",1)\n    };\n    let unsubscribeWifiData = wifiData.subscribe(data => {\n      if (data != null) {\n        if (!once) {\n          initialize(data);\n          once = true;\n        }\n        if (data.type != undefined) {\n          console.log(\"brush trigger data change\", data.type);\n          updateData(data.data);\n        } else {\n          updateData(data);\n        }\n      }\n    });\n  });\n</script>\n\n<style>\n  main {\n    text-align: center;\n    padding: 1em;\n    max-width: 240px;\n    margin: 0 auto;\n  }\n  #leafletHolder {\n    width: 100%;\n  }\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  @media (min-width: 640px) {\n    main {\n      max-width: none;\n    }\n  }\n  #mapid {\n    height: 80vh;\n  }\n  #legendHolder {\n    position: absolute;\n    right: 0px;\n    background: white;\n    border-radius: 10px;\n    border: 1px black solid;\n    padding: 10px;\n    z-index: 5000;\n  }\n</style>\n\n<div id=\"leafletHolder\">\n  <div id=\"mapid\">\n\n    <div id=\"legendHolder\">\n      <p id=\"legendInfo\">Estimated Minutes Spent in Area</p>\n      <svg id=\"legend\" />\n    </div>\n  </div>\n</div>\n",
    "<script>\n  export let building, time,  screen;\n  //\n\n  let holder, svg, xIcon;\n  import { onMount } from \"svelte\";\n  onMount(() => {\n    holder.style.left = screen.x + \"px\";\n    holder.style.top = screen.y + \"px\";\n  });\n</script>\n\n<style>\n  #popoutHolder {\n    position: absolute;\n    background: white;\n    border-radius: 10px;\n    z-index: 2000;\n  }\n  #top {\n    display: flex;\n    justify-content: space-between;\n  }\n  #exit {\n  }\n</style>\n\n<div id=\"popoutHolder\" bind:this={holder}>\n  <div id=\"text\">\n    <p>Estimated Time: {time}</p>\n  </div>\n</div>\n",
    "\n<style>\n#headerRow{\n  display:flex;\n  align-items:center;\n}</style>\n<header class=\"l-arizona-header bg-red\" id=\"region_header_ua\">\n    <section class=\"container l-container\">\n      <div class=\"row\" id=\"headerRow\">\n      <div id=\"bbHolder\"></div><a class=\"arizona-logo\" href=\"http://www.arizona.edu\" title=\"The University of Arizona homepage\"><img class=\"arizona-line-logo\" alt=\"The University of Arizona Wordmark Line Logo White\" src=\"https://cdn.uadigital.arizona.edu/logos/v1.0.0/ua_wordmark_line_logo_white_rgb.min.svg\"></a></div>\n    </section>\n  </header>",
    "<script>\n  export let imgSrc, summaryText;\n  import {onMount} from \"svelte\"\n  let imgElement\n  let holder\n  let content\n  onMount(()=> {\n    holder.style[\"background-image\"] = `url(${imgSrc})`\n  })\n</script>\n\n<style>\n* {\n    z-index: 5;\n}\n#optionHolder {\n    cursor:pointer;\n}\n#optionHolder img {\n    z-index: 1;\n}\n.textElement {\n    box-shadow: 0 7px 23px 0 rgba(32, 44, 62, 0.68);\n    border-radius: 10px;\n    margin:5%;\n    padding:5%;\n    background:white;\n}\n#title {\n    padding: 2%;\n}\n#summary{\n    text-align:center;\n}\n#content {\n    display:flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items:center;\n    width:80%;\n    margin:0 auto;\n    padding-top:18%;\n    padding-bottom:20%;\n}\n</style>\n\n\n<div id=\"optionHolder\" bind:this={holder}>\n  <div id=\"content\" bind:this={content}>\n  <div id=\"summary\" class=\"textElement\">\n    <p>{summaryText}</p>\n  </div>\n  </div>\n</div>\n",
    "<script>\n  let goBack = () => {\n    // destroy gotovis cookie\n    document.cookie = \"gotovis=false\"\n    location.reload();\n  };\n  let arrowEle,pEle\n  let content\n    let entering = ()=> {\n        arrowEle.style.color = \"black\"\n        pEle.style.color = \"black\"\n    }\n    let leaving =()=> {\n        arrowEle.style.color = \"white\"\n        pEle.style.color = \"white\"\n    }\n</script>\n\n<style>\n  #content {\n    display: flex;\n  }\n  #arrow {\n    font-size: 30px;\n    margin: 19px 0 20px;\n    color: white;\n  }\n  p {\n    margin: 24px 0 20px;\n    color: white;\n  }\n  #content {\n    cursor: pointer;\n  }\n</style>\n\n<div id=\"content\"  on:mouseenter={entering} on:mouseleave={leaving} on:click={goBack} >\n  <div bind:this={arrowEle} id=\"arrow\" class=\"ua-brand-left-arrow\" />\n  <div id=\"name\">\n    <p bind:this={pEle}>Memory Jog Map |</p>\n  </div>\n</div>\n",
    "<script>\n  import * as d3 from \"d3\";\n  import { onMount } from \"svelte\";\n  import {\n    wifiData,\n    timeSelected,\n    allDevices,\n    daySelected,\n    timeBounds,\n    timeRange\n  } from \"./store.js\";\n  // make brushable dimensions element, set this from the view that can query size of other elements on screen\n  export let dims;\n  onMount(() => {\n    // setup, and there may be reason to update some variables that are declared\n    let userData,\n      svg,\n      times,\n      buildings,\n      devices,\n      ogXscale,\n      xscale,\n      zoom,\n      yscale,\n      brushXAxis,\n      brushXAxisG,\n      blocksG,\n      currentExt,\n      brush,\n      gbrush,\n      t1,\n      t2;\n\n        const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };\n        const dateTimeFormat = new Intl.DateTimeFormat('en-US', options);\n    let calcWidth = d => {\n      let start = d3.isoParse(d._time);\n      let duration = d.niceDuration.split(\":\").map(e => parseInt(e));\n      // if duration is 0 show it as a 1 minute section so its detectable in brush region\n      if (duration.reduce((a, b) => a + b, 0) == 0) {\n        start.setSeconds(start.getSeconds() + 1);\n      } else {\n        start.setMinutes(start.getMinutes() + duration[1]);\n        start.setSeconds(start.getSeconds() + duration[2]);\n        start.setHours(start.getHours() + duration[0]);\n      }\n      return start;\n    };\n    function zoomed(e) {\n      let rescalex = d3.event.transform.rescaleX(ogXscale);\n      xscale = rescalex;\n      // redraw the contents of the graph, do I also need to change the brush?\n      brushXAxis.scale(rescalex);\n      brushXAxisG.call(brushXAxis);\n      if (currentExt != undefined) {\n\n        gbrush.call(brush.move,currentExt)\n      }\n      redraw();\n    }\n    let initialize = () => {\n      //scaleExtent controls min and max scale factor\n      // translate controls the possible translation , extent is [[x0,y0],[x1,y1]] where the first corresponds  to the top left, and the second the bottom right\n      // mostly makes it so you don't pan out of data realm\n      zoom = d3\n        .zoom()\n        .scaleExtent([1, 20])\n        .translateExtent([[dims.margin, -Infinity], [dims.width - dims.margin, Infinity]])\n        .on(\"zoom\", zoomed);\n      svg = d3\n        .select(\"#brushableHolder\")\n        .append(\"svg\")\n        .attr(\"width\", dims.width)\n        .attr(\"height\", dims.height);\n      svg.call(zoom);\n      times = [];\n      buildings = [];\n      devices = {};\n      for (let entry of userData) {\n        times.push({start:d3.isoParse(entry._time),end:calcWidth(entry)});\n        if (buildings.indexOf(entry.apBuildingNumber) == -1) {\n          buildings.push(entry.apBuildingNumber);\n        }\n        if (devices[entry[\"deviceType\"]] == undefined) {\n          devices[entry[\"deviceType\"]] = { checked: true };\n        }\n      }\n      // \n      let last_time = new Date(d3.max(times.map(e=> e.end)).getTime());\n      last_time.setHours(last_time.getHours() + 1);\n      // create the xscale that handles time\n      let first_time = new Date(d3.min(times.map(e=> e.start)).getTime());\n      first_time.setHours(first_time.getHours() - 1);\n\n      xscale = d3\n        .scaleTime()\n        .domain([first_time, last_time])\n        .range([0, dims.width - dims.margin * 2]);\n      // allows us to make changes to xscale for everywhere else, except the zoom baseline\n      ogXscale = xscale.copy();\n      // set the times to be the values used in the dataSelectors component\n      timeSelected.update(() => [d3.min(times), last_time]);\n      allDevices.set(devices);\n      // make all the same rectangles but with different ydims\n      yscale = d3\n        .scaleBand()\n        .domain(d3.range(buildings.length + 1))\n        .range([0, dims.height - dims.margin]);\n      // make a k\n      let clipPath = svg.append(\"g\")\n      .attr(\"transform\",`translate(${dims.margin},${dims.margin})`)\n      .append(\"clipPath\")\n      .attr(\"id\",\"cliprect\")\n      .append(\"rect\")\n      .attr(\"width\",dims.width - dims.margin*2)\n      .attr(\"height\",dims.height)\n      // make a label axis for bottom chart\n      brushXAxis = d3.axisTop(xscale).tickPadding(0);\n      brushXAxisG = svg\n        .append(\"g\")\n        .attr(\"class\", \"brushAxis\")\n        .attr(\"transform\", `translate(${dims.margin},${dims.margin})`)\n        .call(brushXAxis);\n      // make cursor into pointer on ticks to indicate drag options\n      d3.selectAll(\".tick\").style(\"cursor\", \"pointer\");\n      d3.selectAll(\".tick text\").style(\"cursor\", \"pointer\");\n      blocksG = svg\n        .append(\"g\")\n        .attr(\"transform\", `translate(${dims.margin},${dims.margin})`)\n        .attr(\"clip-path\",\"url(#cliprect)\");\n\n      // brush steps\n      //define a brush event\n      function brushEnd() {\n        const ext = d3.brushSelection(this);\n        t1 = xscale.invert(ext[0]);\n        t2 = xscale.invert(ext[1]);\n        currentExt = ext\n        // update  data shown for the graph, but make it clear that this is not supposed to update the brushable area\n        let timeBoundedData = [];\n        for (let entry of userData) {\n          // 8 cases, TODO this can probably be condensed\n          let st = d3.isoParse(entry._time);\n          // think about the 0 duration entries?\n          let end = calcWidth(entry);\n          //replace the st and ends in the entry at the end\n          // copy so that we don't accidentally mess up any original data\n          let resEntry = { ...entry };\n          if (st < t1) {\n            resEntry._time = t1.getTime();\n            if (end < t2 && end > t1) {\n              // substitute the extent for the start because its out of brushable region\n              // remove as much time from the end as nec to calculate correct nice duration again\n              let delta = end.getTime() - t1.getTime();\n              resEntry.niceDuration = `${Math.floor(\n                delta / (1000 * 60 * 60)\n              )}:${Math.floor((delta / (1000 * 60)) % 60)}:${Math.floor(\n                (delta / 1000) % 60\n              )}`;\n              timeBoundedData.push(resEntry);\n            } else if (end > t2) {\n              // delta is duration in ms\n              let delta = t2.getTime() - t1.getTime();\n              resEntry.niceDuration = `${Math.floor(\n                delta / (1000 * 60 * 60)\n              )}:${Math.floor((delta / (1000 * 60)) % 60)}:${Math.floor(\n                (delta / 1000) % 60\n              )}`;\n              timeBoundedData.push(resEntry);\n            }\n          } else if (st < t2 && st > t1) {\n            //assumption isend is greater than t1 since end > st, so not writing it\n            if (end < t1) {\n              console.error(\"data problem with end\", end, \"check calcwidth\");\n              continue;\n            }\n            if (end < t2) {\n              // substitute the extent for the start because its out of brushable region\n              // don't modify duration\n              if (resEntry.niceDuration.match(/16/)) {\n                console.log(resEntry.niceDuration);\n              }\n              timeBoundedData.push(resEntry);\n            } else if (end > t2) {\n              // delta is duration in ms\n              let delta = t2.getTime() - st.getTime();\n              resEntry.niceDuration = `${Math.floor(\n                delta / (1000 * 60 * 60)\n              )}:${Math.floor((delta / (1000 * 60)) % 60)}:${Math.floor(\n                (delta / 1000) % 60\n              )}`;\n              timeBoundedData.push(resEntry);\n            }\n          }\n        }\n        let timesOnly = timeBoundedData.map(e=> new Date(e._time))\n        let rangeextent = d3.extent(timesOnly);\n\n        timeRange.set({\n          start: dateTimeFormat.format( rangeextent[0]),\n          end: dateTimeFormat.format(rangeextent[1])\n        });\n        // update the map data\n        wifiData.set({ type: \"brushupdate\", data: timeBoundedData });\n      }\n      // create a brush\n      // define functions for start and brushed\n      // extent is the possible canvas that can be brushed\n      brush = d3\n        .brushX()\n        .on(\"end\", brushEnd)\n        .on(\"brush\", brushEnd)\n        .extent([\n          [0, 0],\n          [dims.width - dims.margin, dims.height - dims.margin]\n        ]);\n      // create a g element, and define a class for the brush\n      gbrush = blocksG.append(\"g\").attr(\"class\", \"gBrush\");\n      gbrush.call(brush);\n      // call the brush constructor with .call\n      redraw(xscale);\n      // force select first day\n      let firstDay = xscale.domain()[0];\n      // set the hours,minutes,seconds to 0,\n      firstDay.setHours(0);\n      firstDay.setMinutes(0);\n      firstDay.setSeconds(0);\n      // min domain is actuall 24 hours earlier than first data day, as buffer\n      firstDay.setHours(firstDay.getHours() + 24);\n      daySelected.set(firstDay);\n    };\n    let redraw = () => {\n      // include the vertical lines at the day intervals\n      let start = xscale.domain()[0];\n      // truncate start back to beginning of day\n      start.setHours(0);\n      start.setMinutes(0);\n      start.setSeconds(0);\n      let end = xscale.domain()[1];\n      let current = new Date(start.getTime());\n      d3.selectAll(\".vertDayMark\").remove();\n      for (let i = 0; ; i++) {\n        let pathData = [\n          [xscale(current), 0],\n          [xscale(current), yscale.range()[1]]\n        ];\n        let lineGenerator = d3\n          .line()\n          .x(d => d[0])\n          .y(d => d[1]);\n        blocksG\n          .append(\"path\")\n          .datum(pathData)\n          .attr(\"stroke\", \"red\")\n          .attr(\"class\", \"vertDayMark\")\n          .attr(\"d\", lineGenerator);\n        current.setMinutes(current.getMinutes() + 60 * 24);\n        if (current > end) {\n          break;\n        }\n      }\n      // make the small blocks\n      blocksG\n        .selectAll(\"rect\")\n        .data(userData, d => d._time)\n        .join(\n          enter =>\n            enter\n              .append(\"rect\")\n              .attr(\"x\", d => xscale(d3.isoParse(d._time)))\n              .attr(\"y\", (d, i) =>\n                yscale(buildings.indexOf(d.apBuildingNumber))\n              )\n              .attr(\"height\", yscale.bandwidth())\n              .attr(\"width\", d => {\n                return xscale(calcWidth(d)) - xscale(d3.isoParse(d._time));\n              }),\n          update =>\n            update\n              .attr(\"x\", d => xscale(d3.isoParse(d._time)))\n              .attr(\"width\", d => {\n                return xscale(calcWidth(d)) - xscale(d3.isoParse(d._time));\n              }),\n          exit => exit.remove()\n        );\n      gbrush.call(brush);\n    };\n    let unsubscribe = wifiData.subscribe(data => {\n      if (data != null) {\n        if (svg == undefined) {\n          userData = data;\n          initialize();\n        } else {\n          // do redraw\n          if (data.type != undefined) {\n            // this is a brush based update\n            console.log(\"brush updated the data\");\n          } else {\n            // see if we have brush and alter the data\n            if (t1 != undefined) {\n              let timeBoundedData = [];\n              for (let entry of data) {\n                let etime = d3.isoParse(entry._time);\n                if (etime > t1 && etime < t2) {\n                  timeBoundedData.push(entry);\n                }\n              }\n              wifiData.set({ type: \"brush\", data: timeBoundedData });\n            }\n            userData = data;\n            redraw();\n          }\n        }\n      }\n    });\n    let unsubDaySelected = daySelected.subscribe(day => {\n      // update the brush\n      if (day != 0) {\n        console.log(\"updating brush\");\n        let nextDay = new Date(day.getTime());\n        nextDay.setMinutes(nextDay.getMinutes() + 60 * 24);\n        // invert xscale and get the positions of day and day + 24 hours\n        let dayX = xscale(day);\n        let nextDayX = xscale(nextDay);\n        gbrush.call(brush.move, [dayX, nextDayX]);\n        // triggers the brushEnd event\n      }\n    });\n  });\n</script>\n\n<style>\n#info {\n  display:flex;\n}\np {\n  display:block;\n  font-size:12px;\n  width:50%;\n}\n</style>\n<div id=\"info\">\n<p> This map is currently showing the time period <b>{$timeRange.start}</b> - <b>{$timeRange.end}</b></p>\n  <p><b>Instructions: </b> To select a specific day, drag mouse across the date selector below. To select a specific time period, increase the size of the selector by double-clicking, or use mouse wheel to zoom in. Hover the mouse pointer over map circles to get estimated time spent in area.</p>\n  \n</div>\n<div id=\"brushableHolder\">\n</div>\n",
    "<script>\n    import {onMount} from \"svelte\"\n    import {daySelected} from \"./store.js\"\n    let selectElement\n    export let duration\n    let actualDates ={}\n    let firstDate\n\n        const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };\n        const dateTimeFormat = new Intl.DateTimeFormat('en-US', options);\n\n    onMount(()=> {\n        // break down the duration into a span of days. \n        // loop and add dates in 24hour incs until we are greater than the end duration\n        let start = duration[0]\n        start.setHours(0)\n        start.setMinutes(0)\n        start.setSeconds(0)\n        let end = duration[1]\n        let current = new Date(start.getTime())\n        for (let i = 0;;i++) {\n            let e = document.createElement(\"option\")\n            e.value = JSON.stringify(current)\n            e.innerHTML = dateTimeFormat.format(current)\n            actualDates[e.value] = new Date(current.getTime())\n            document.querySelector(\"#days\").append(e)\n            if (i == 0) {\n                firstDate = actualDates[e.value]\n            }\n            current.setMinutes(current.getMinutes() + 60*24)\n            if (current > end) {\n                break\n            }\n\n        }\n        daySelected.set(firstDate)\n    })\n    // when selection changes, set the daySelected, this will trigger an auto brush in the lower view\n    let selectionMade = ()=> {\n        console.log(\"change in selection to\",selectElement.value);\n        daySelected.set(actualDates[selectElement.value])\n    }\n\n    \n</script>\n<style>\n#content {\n    display:flex;\n}\n</style>\n<div id=\"content\">\n<select name=\"\" id=\"days\" bind:this={selectElement} on:change={selectionMade}>\n</select>\n</div>",
    "<script>\n  import { onMount } from \"svelte\";\n  import BB from \"./backButton.svelte\";\n  import Map from \"./Map.svelte\";\n  import Brushable from \"./brushableIndividual.svelte\";\n  import Selectors from \"./dataSelectors.svelte\";\n  import { buildingJSON } from \"./buildingData.js\";\n  import { wifiData } from \"./store.js\";\n  // setup the store with the data for this application\n  let visHolder;\n  let dims = {\n    width: window.innerWidth * 0.99,\n    height: 100,\n    margin: 20\n  };\n  onMount(() => {\n    new BB({\n      target: document.querySelector(\"#bbHolder\")\n    });\n  });\n</script>\n\n<style>\n  #secondVisHolder {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    width: 100%;\n  }\n</style>\n\n<div id=\"secondVisHolder\">\n  <div id=\"topViews\">\n\n    <Brushable {dims} />\n  </div>\n  <Map {buildingJSON} />\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}