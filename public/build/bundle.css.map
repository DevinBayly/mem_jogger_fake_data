{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../DensityMap.svelte",
    "../../Popout.svelte",
    "../../density_vis.svelte",
    "../../overlayVid.svelte"
  ],
  "sourcesContent": [
    "<script>\n  export let name;\n  import VidOverlay from \"./overlayVid.svelte\"\n  import * as d3 from \"d3\";\n  import Gant from \"./gant_chart.svelte\";\n  window.onload = async () => {\n    let paulData = await fetch(\n      \"location_data.json\"\n    ).then(res => res.json());\n    // remove the eventData attribute on everything\n    paulData = paulData.map(e=> {\n      e = e.eventData\n      // perform other important conversionss\n      // make seconds into ms for date creation\n      e._time = parseInt(e._time)*1000\n      return e\n    })\n    console.log(paulData);\n    let buildingNameData = await fetch(\n      \"building_names.csv\"\n    ).then(res => res.text());\n    let dsv = d3.dsvFormat(\",\");\n    buildingNameData = dsv.parse(buildingNameData);\n    console.log(paulData, buildingNameData);\n    const graph = new Gant({\n      target: document.body,\n      props: {\n        data: paulData,\n        buildingData: buildingNameData\n      }\n    });\n  };\n</script>\n\n<style>\n  main {\n    text-align: center;\n    padding: 1em;\n    max-width: 240px;\n    margin: 0 auto;\n  }\n\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  @media (min-width: 640px) {\n    main {\n      max-width: none;\n    }\n  }\n</style>\n\n<VidOverlay></VidOverlay>\n\n<div id=\"tooltipHolder\">\n  <p id=\"tipText\" />\n</div>\n<div id=\"graphs\">\n  <div id=\"topaxisholder\">\n    <svg id=\"topaxis\">\n    </svg>\n  </div>\n  <div id=\"topgraph\">\n    <svg id=\"main\" />\n  </div>\n  <div id=\"bottomgraph\">\n    <svg id=\"brushable\" />\n  </div>\n</div>\n",
    "<script>\n  export let buildingJSON;\n  import Popout from \"./Popout.svelte\"\n  import { onMount } from \"svelte\";\n  import { mapData } from \"./store.js\";\n  import * as d3 from \"d3\";\n  import legend from \"d3-svg-legend\"\n  onMount(async () => {\n    console.log(\"loaded\");\n    console.log(\"building Json is \", buildingJSON);\n    let mymap = L.map(\"mapid\").setView([32.231481, -110.951838], 18);\n    L.esri.basemapLayer(\"Gray\").addTo(mymap);\n    var subtleUA = L.esri\n      .tiledMapLayer({\n        url:\n          \"https://services.maps.arizona.edu/pdc/rest/services/SubtleCanvasTiles/MapServer\"\n      })\n      .addTo(mymap);\n    // this  is the magic line for converting the polygon data into useful values\n    /*\n      let point = new L.Point(centerL20[0],centerL20[1])\n      let pointLatLng = L.Projection.SphericalMercator.unproject(point)\n      */\n    // TODO think about preconfiguring the buildingJSON to be a map already just with coordinates and building numbers\n    let buildingMap = {};\n    let nameMap = {}\n    for (let feature of buildingJSON.features) {\n      // recall that the coordinates are owifiDatardered x,y in geojson, so must put into conversion correctly\n      //\n      buildingMap[\n        feature.properties[\"Buildings.SpaceNumLetter\"]\n      ] = new L.LatLng(\n        feature.geometry.coordinates[1],\n        feature.geometry.coordinates[0]\n      );\n      nameMap[feature.properties[\"Buildings.SpaceNumLetter\"]] = feature.properties[\"Buildings.Name\"]\n    }\n    console.log(\"building map is \",buildingMap)\n\n    // subscribe to the store\n    let once = false;\n    let graphData,\n      legendSvg,\n      legendG,\n      circleLegend,\n      circleOpacityScale,\n      applyLatLngToLayer,\n      bboxNWLatLng,\n      bboxSELatLng,\n      svg,\n      maxRadius = 20,\n      g;\n    let redraw = function() {\n      // need a function to calculate the bounds of the points\n      console.log(\"redrawing\");\n      // occasionally when zooming and panning the svg's container move, so we have to set svg to be relative and move it left and right\n\n      // make a circle and append it to the svg, and then transform it with the results of the applylatlng\n      let circle = g\n        .selectAll(\".testPoints\")\n        .data(graphData, d => d.number)\n        .join(\n          enter =>\n            enter\n              .append(\"circle\")\n              .attr(\"r\",10)\n              .attr(\"class\", \"testPoints\")\n              .attr(\"transform\", d => {\n                if (d.coords == undefined) {\n                  //console.log(\"missing coords on\", d);\n                } else {\n                  return `translate(${applyLatLngToLayer(d.coords).x},${\n                    applyLatLngToLayer(d.coords).y\n                  })`;\n                }\n              })\n              .attr(\"fill\",d=> circleOpacityScale(d)),\n          update =>\n            update.attr(\"transform\", d => {\n              if (d.coords == undefined) {\n                //console.log(\"missing coords on\", d);\n              } else {\n                return `translate(${applyLatLngToLayer(d.coords).x},${\n                  applyLatLngToLayer(d.coords).y\n                })`;\n              }\n            })\n            .attr(\"fill\",d=> circleOpacityScale(d.count)),\n          exit => exit.remove()\n        );\n      // section for binding click events to the generation of popouts\n      circle.on(\"click\",function() {\n        let circ = d3.select(this)\n        let data = circ.data()[0]\n        //get the xy, and make a new popout, push the popout to collection to remove on zoom\n        new Popout({\n          target:mymap.getPanes().overlayPane,\n          props:{\n            building:nameMap[data.number],\n            number:data.number,\n            headCount:data.count,\n            screen:applyLatLngToLayer(data.coords)\n          }\n        })\n      })\n\n      // the width is the diff nw and se bbox points\n      let screenNW = applyLatLngToLayer(bboxNWLatLng);\n      let screenSE = applyLatLngToLayer(bboxSELatLng);\n      // make sure the circles don't get cut off, so we add a radius on all edges of SVG\n      svg.attr(\"width\", screenSE.x - screenNW.x + 2 * maxRadius);\n      svg.attr(\"height\", screenSE.y - screenNW.y + 2 * maxRadius);\n      // get the pixel coordinates of the top left corner of bbox\n      // subtract some left so we don't cutt off the circles\n      svg.style(\"left\", screenNW.x - maxRadius + \"px\");\n      svg.style(\"top\", screenNW.y - maxRadius + \"px\");\n      // now update the g that is containing the circles\n      // add in the circle radius because points need to shift extra given the padded space\n      g.attr(\n        \"transform\",\n        `translate(${-screenNW.x + maxRadius},${-screenNW.y + maxRadius})`\n      );\n    };\n    let updateData = userData => {\n      let maxCount = Math.max(...userData.map(e=>e.count))\n      circleOpacityScale.domain([1,maxCount])\n      legendG.call(circleLegend)\n      console.log(\"running data\")\n      if (userData.length == 0) {\n        // just pick a graphData \n        graphData =[] \n        redraw()\n        return\n      }\n      let activeBuildings = {};\n      for (let connection of userData) {\n        if (activeBuildings[connection.latestBuilding] == undefined) {\n          activeBuildings[connection.latestBuilding] = {\n            coords: buildingMap[connection.latestBuilding],\n            count: connection.count,\n            number: connection.latestBuilding\n          };\n        } else {\n          activeBuildings[connection.latestBuilding].count += 1;\n        }\n      }\n      // convert active Buildings into an array for simplicity in D3\n      graphData = [];\n      for (let building in activeBuildings) {\n        graphData.push(activeBuildings[building]);\n      }\n      console.log(\"graph data \",graphData)\n      // calculate the nw corner of a bounding box on the points\n      let bbox = { x: {}, y: {} };\n      // calculate the bounding box on the circles that are being drawn, decide on a max radius, and use it\n      for (let i = 0; i < graphData.length; i++) {\n        let d = graphData[i].coords;\n        if (d == undefined) {\n          console.log(\"missing coords\", d);\n          continue;\n        }\n        if (i == 0) {\n          // set minmax off the bat\n          bbox.x.min = bbox.x.max = d.lng;\n          bbox.y.min = bbox.y.max = d.lat;\n          continue;\n        }\n        if (d.lat > bbox.y.max) {\n          bbox.y.max = d.lat;\n        }\n        if (d.lat < bbox.y.min) {\n          bbox.y.min = d.lat;\n        }\n        if (d.lng > bbox.x.max) {\n          bbox.x.max = d.lng;\n        }\n        if (d.lng < bbox.x.min) {\n          bbox.x.min = d.lng;\n        }\n      }\n      // the northwest corner is the max.y and the min.x, and the south east corner is the min.y and the max.x\n      console.log(\"boundsbox is\", bbox);\n      bboxNWLatLng = new L.LatLng(bbox.y.max, bbox.x.min);\n      bboxSELatLng = new L.LatLng(bbox.y.min, bbox.x.max);\n      redraw()\n    }\n    let initialize = (userData) => {\n\n      // this is the width the svg should be to cover the full map\n      let bounds = mymap.getPixelBounds();\n      let width = bounds.max.x - bounds.min.x;\n      let height = bounds.max.y - bounds.min.y;\n      // create an svg\n      svg = d3.select(mymap.getPanes().overlayPane).append(\"svg\");\n      g = svg.append(\"g\").attr(\"class\", \"leaflet-zoom-hide\");\n      // define apply latlng to layer that takes in geopoints and produces screenspace x,y for drawing on svg\n      // NOTE that geojson points are going to have the x first in the coordinates\n      applyLatLngToLayer = function(d) {\n        // d is a lat lng calculated from the getCenter() method of a polyline\n        // do some comparison of building number to geojson of buildings to get coords\n        return mymap.latLngToLayerPoint(d);\n      };\n      // connect redraw to the map events\n      mymap.on(\"zoomend\", redraw);\n      mymap.on(\"moveend\", redraw);\n      //establish the circle scale before the data gets changed at all\n      let maxCount = Math.max(...userData.map(e=>e.count))\n      circleOpacityScale = d3\n        .scaleLinear()\n        .domain([1, maxCount])\n        .range([\"rgba(255,0,0,.1)\",\"rgba(255,0,0,1)\"])\n      //make a legend\n      legendSvg = d3.select(\"#legend\")\n      legendG = legendSvg.append(\"g\").attr(\"class\",\"legend\").attr(\"transform\",\"translate(10,20)\")\n      circleLegend = legend.legendColor()\n      .scale(circleOpacityScale)\n      .shape(\"circle\")\n      .shapePadding(20)\n      .labelOffset(20)\n      .orient(\"vertical\")\n      legendG.call(circleLegend)\n      d3.select(\"#legendHolder\").style(\"width\",legendG.node().getBoundingClientRect().width+\"px\")\n      legendSvg.attr(\"height\",(legendG.node().getBoundingClientRect().height + 20) +\"px\")\n\n    };\n    let unsubscribeDensity = mapData.subscribe(data => {\n      if(data.length == 0){\n        return\n      }\n      if (!once) {\n        initialize(data);\n        once = true\n      }\n      updateData(data)\n    });\n  });\n</script>\n\n<style>\n  main {\n    text-align: center;\n    padding: 1em;\n    max-width: 240px;\n    margin: 0 auto;\n  }\n  #leafletHolder {\n    width: 100%;\n  }\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  @media (min-width: 640px) {\n    main {\n      max-width: none;\n    }\n  }\n  #mapid {\n    height: 80vh;\n  }\n  #legendHolder {\n    position:absolute;\n    top:0px;\n    right:0px;\n    z-index:5000;\n    background:white;\n    border-radius:10px;\n    padding:5px;\n  }\n</style>\n\n<div id=\"leafletHolder\">\n  <div id=\"mapid\" />\n</div>\n<div id=\"legendHolder\">\n<p>People Connected</p>\n<svg id=\"legend\">\n</svg></div>",
    "<script>\nimport {histogram} from \"./histPopout.js\"\nimport {mapData} from \"./store.js\"\nexport let building,headCount,number,screen\n\n\nlet holder,svg,xIcon\nimport {onMount} from \"svelte\"\nonMount(()=> {\n    holder.style.left = screen.x + \"px\"\n    holder.style.top = screen.y + \"px\"\n    holder.style.width = svg.getBoundingClientRect().width + \"px\"\n    // create the histogram\n    histogram(svg,number,{width:svg.getBoundingClientRect().width,height:svg.getBoundingClientRect().height,margin:40})\n    // potential mem leak if too many popouts made and closed without unsubscribing\n    mapData.subscribe(data=> {\n        // find the building for this popout and updatethe headcount\n        if (data!=null) {\n\n        for(let d of data) {\n            if (d.latestBuilding == number) {\n                console.log(\"changed building\",number,headCount, \"to\",d.count)\n                headCount = d.count\n            }\n        }\n        }\n    })\n\n})\n\nlet removePopout = ()=> {\n    holder.remove()\n}\n</script>\n\n<style>\n#popoutHolder {\n    position:absolute;\n    background:white;\n    border-radius:10px;\n    z-index:2000;\n}\n#top {\n    display:flex;\n    justify-content: space-between;\n}\n#exit {\n}\n\n</style>\n\n<div id=\"popoutHolder\" bind:this={holder}>\n<div id=\"top\">\n<div id=\"text\">\n<p>Building: {building}</p>\n<p>HeadCount: {headCount}</p>\n</div>\n<div id=\"exitHolder\">\n<img src=\"x.png\" alt=\"\" id=\"exit\" on:click={removePopout} bind:this={xIcon}>\n</div>\n</div>\n<svg id=\"histogram\" bind:this={svg}></svg>\n</div>",
    "<script>\nimport Map from \"./DensityMap.svelte\"\nimport Brushable from \"./brushableDensity.svelte\"\nimport {buildingJSON} from \"./data.js\"\n// setup the store with the data for this application\n\nlet dims ={\n  width:window.innerWidth,\n  height:100,\n  margin:20\n}\n</script>\n\n<style>\n#secondVisHolder {\n  display:flex;\n  flex-direction: column;\n  height:100%;\n  width:100%;\n\n}\n#bottomViews {\n  display:flex;\n\n}\n</style>\n\n<div id=\"secondVisHolder\">\n<Map buildingJSON={buildingJSON}></Map>\n<div id=\"lower\">\n<Brushable dims={dims}></Brushable>\n</div>\n</div>",
    "<style>\n  #innerholder {\n    position: relative;\n    top: -50%;\n    left: -50%;\n    background: white;\n    border-radius: 6px;\n  }\n  #vidholder {\n      z-index: 5000;\n      position:absolute;\n      top:25%;\n      left:50%;\n  }\n#overlay {\n    position:fixed;\n    top:0px;\n    left:0px;\n    height:100%;\n    width:100%;\n    background:rgba(100,100,100,.7);\n}\nvideo{\n    width:750px;\n}\n\n</style>\n\n<div id=\"vidholder\">\n    <div id=\"overlay\" />\n  <div id=\"innerholder\">\n    <video src=\"explanation.webm\" id=\"intro\" autoplay controls />\n    <div\n      id=\"close\"\n      on:click={() => {\n        document.querySelector('#vidholder').remove();\n      }}>\n      <h2>Close</h2>\n    </div>\n  </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "AAiDE,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAI3B,CAAC;ACgMD,cAAc,eAAC,CAAC,AACd,KAAK,CAAE,IAAI,AACb,CAAC,AAQD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAI3B,CAAC,AACD,MAAM,eAAC,CAAC,AACN,MAAM,CAAE,IAAI,AACd,CAAC,AACD,aAAa,eAAC,CAAC,AACb,SAAS,QAAQ,CACjB,IAAI,GAAG,CACP,MAAM,GAAG,CACT,QAAQ,IAAI,CACZ,WAAW,KAAK,CAChB,cAAc,IAAI,CAClB,QAAQ,GAAG,AACb,CAAC;AC3OH,aAAa,cAAC,CAAC,AACX,SAAS,QAAQ,CACjB,WAAW,KAAK,CAChB,cAAc,IAAI,CAClB,QAAQ,IAAI,AAChB,CAAC,AACD,IAAI,cAAC,CAAC,AACF,QAAQ,IAAI,CACZ,eAAe,CAAE,aAAa,AAClC,CAAC,AACD,KAAK,cAAC,CAAC,AACP,CAAC;ACjCD,gBAAgB,eAAC,CAAC,AAChB,QAAQ,IAAI,CACZ,cAAc,CAAE,MAAM,CACtB,OAAO,IAAI,CACX,MAAM,IAAI,AAEZ,CAAC;ACnBC,YAAY,cAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,UAAU,CAAE,KAAK,CACjB,aAAa,CAAE,GAAG,AACpB,CAAC,AACD,UAAU,cAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,SAAS,QAAQ,CACjB,IAAI,GAAG,CACP,KAAK,GAAG,AACZ,CAAC,AACH,QAAQ,cAAC,CAAC,AACN,SAAS,KAAK,CACd,IAAI,GAAG,CACP,KAAK,GAAG,CACR,OAAO,IAAI,CACX,MAAM,IAAI,CACV,WAAW,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,AACnC,CAAC,AACD,mBAAK,CAAC,AACF,MAAM,KAAK,AACf,CAAC"
}