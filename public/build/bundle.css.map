{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../DensityMap.svelte",
    "../../Map.svelte",
    "../../Popout.svelte",
    "../../VisOption.svelte",
    "../../checkboxes.svelte",
    "../../density_vis.svelte",
    "../../gantt_vis.svelte",
    "../../map_vis.svelte",
    "../../overlayVid.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import VisOp from \"./VisOption.svelte\"\n  import MapApplication from \"./map_vis.svelte\"\n  import GanttApplication from \"./gantt_vis.svelte\"\n  // put in Teresa's signin code\n  // include the reachout to the lambda function\n  // introduce the page with the options\n  let holder\n  let gantt= ()=> {\n    holder.remove()\n    new GanttApplication({\n      target:document.body\n    })\n    console.log(\"loading gantt\")\n  }\n  let map = ()=> {\n    console.log(\"loading map\")\n    // remove holder\n    holder.remove()\n    new MapApplication({\n      target:document.body,\n      props:{}\n    })\n  }\n</script>\n\n<style>\n\n* {\n    z-index: 5;\n}\n#holder {\n  height:100%;\n  background:#183055;\n  color:white;\n}\n#title {\n  display:flex;\n  justify-content: center;\n}\n#options {\n  cursor:pointer;\n  display:flex;\n  justify-content: center;\n  height:100%;\n}\n</style>\n\n<div id=\"holder\" bind:this={holder}>\n  <div id=\"title\">\n    <h3>Memory Jogger</h3>\n  </div>\n  <div id=\"options\">\n  <div id=\"gantt-side\" on:click={gantt}>\n    <VisOp imgSrc=\"gantt_background.png\" title=\"Gantt Chart\" summaryText=\"View your data from the last 2 weeks with particular attention to the 'when' you were in a location\" ></VisOp>\n  </div>\n  <div id=\"map-side\" on:click={map}>\n  <VisOp imgSrc=\"map_background.png\" title=\"Map Visualization\" summaryText=\"Explore where you've been on campus for over 15 minutes at a time overlaid on this campus map\" ></VisOp>\n  </div>\n  </div>\n</div>\n",
    "<script>\n  export let buildingJSON;\n  import Popout from \"./Popout.svelte\"\n  import { onMount } from \"svelte\";\n  import { mapData } from \"./store.js\";\n  import * as d3 from \"d3\";\n  import legend from \"d3-svg-legend\"\n  onMount(async () => {\n    console.log(\"loaded\");\n    console.log(\"building Json is \", buildingJSON);\n    let mymap = L.map(\"mapid\").setView([32.231481, -110.951838], 18);\n    L.esri.basemapLayer(\"Gray\").addTo(mymap);\n    var subtleUA = L.esri\n      .tiledMapLayer({\n        url:\n          \"https://services.maps.arizona.edu/pdc/rest/services/SubtleCanvasTiles/MapServer\"\n      })\n      .addTo(mymap);\n    // this  is the magic line for converting the polygon data into useful values\n    /*\n      let point = new L.Point(centerL20[0],centerL20[1])\n      let pointLatLng = L.Projection.SphericalMercator.unproject(point)\n      */\n    // TODO think about preconfiguring the buildingJSON to be a map already just with coordinates and building numbers\n    let buildingMap = {};\n    let nameMap = {}\n    for (let feature of buildingJSON.features) {\n      // recall that the coordinates are owifiDatardered x,y in geojson, so must put into conversion correctly\n      //\n      buildingMap[\n        feature.properties[\"Buildings.SpaceNumLetter\"]\n      ] = new L.LatLng(\n        feature.geometry.coordinates[1],\n        feature.geometry.coordinates[0]\n      );\n      nameMap[feature.properties[\"Buildings.SpaceNumLetter\"]] = feature.properties[\"Buildings.Name\"]\n    }\n    console.log(\"building map is \",buildingMap)\n\n    // subscribe to the store\n    let once = false;\n    let graphData,\n      legendSvg,\n      legendG,\n      circleLegend,\n      circleOpacityScale,\n      applyLatLngToLayer,\n      bboxNWLatLng,\n      bboxSELatLng,\n      svg,\n      maxRadius = 20,\n      g;\n    let redraw = function() {\n      // need a function to calculate the bounds of the points\n      console.log(\"redrawing\");\n      // occasionally when zooming and panning the svg's container move, so we have to set svg to be relative and move it left and right\n\n      // make a circle and append it to the svg, and then transform it with the results of the applylatlng\n      let circle = g\n        .selectAll(\".testPoints\")\n        .data(graphData, d => d.number)\n        .join(\n          enter =>\n            enter\n              .append(\"circle\")\n              .attr(\"r\",10)\n              .attr(\"class\", \"testPoints\")\n              .attr(\"transform\", d => {\n                if (d.coords == undefined) {\n                  //console.log(\"missing coords on\", d);\n                } else {\n                  return `translate(${applyLatLngToLayer(d.coords).x},${\n                    applyLatLngToLayer(d.coords).y\n                  })`;\n                }\n              })\n              .attr(\"fill\",d=> circleOpacityScale(d)),\n          update =>\n            update.attr(\"transform\", d => {\n              if (d.coords == undefined) {\n                //console.log(\"missing coords on\", d);\n              } else {\n                return `translate(${applyLatLngToLayer(d.coords).x},${\n                  applyLatLngToLayer(d.coords).y\n                })`;\n              }\n            })\n            .attr(\"fill\",d=> circleOpacityScale(d.count)),\n          exit => exit.remove()\n        );\n      // section for binding click events to the generation of popouts\n      circle.on(\"click\",function() {\n        let circ = d3.select(this)\n        let data = circ.data()[0]\n        //get the xy, and make a new popout, push the popout to collection to remove on zoom\n        new Popout({\n          target:mymap.getPanes().overlayPane,\n          props:{\n            building:nameMap[data.number],\n            number:data.number,\n            headCount:data.count,\n            screen:applyLatLngToLayer(data.coords)\n          }\n        })\n      })\n\n      // the width is the diff nw and se bbox points\n      let screenNW = applyLatLngToLayer(bboxNWLatLng);\n      let screenSE = applyLatLngToLayer(bboxSELatLng);\n      // make sure the circles don't get cut off, so we add a radius on all edges of SVG\n      svg.attr(\"width\", screenSE.x - screenNW.x + 2 * maxRadius);\n      svg.attr(\"height\", screenSE.y - screenNW.y + 2 * maxRadius);\n      // get the pixel coordinates of the top left corner of bbox\n      // subtract some left so we don't cutt off the circles\n      svg.style(\"left\", screenNW.x - maxRadius + \"px\");\n      svg.style(\"top\", screenNW.y - maxRadius + \"px\");\n      // now update the g that is containing the circles\n      // add in the circle radius because points need to shift extra given the padded space\n      g.attr(\n        \"transform\",\n        `translate(${-screenNW.x + maxRadius},${-screenNW.y + maxRadius})`\n      );\n    };\n    let updateData = userData => {\n      let maxCount = Math.max(...userData.map(e=>e.count))\n      circleOpacityScale.domain([1,maxCount])\n      legendG.call(circleLegend)\n      console.log(\"running data\")\n      if (userData.length == 0) {\n        // just pick a graphData \n        graphData =[] \n        redraw()\n        return\n      }\n      let activeBuildings = {};\n      for (let connection of userData) {\n        if (activeBuildings[connection.latestBuilding] == undefined) {\n          activeBuildings[connection.latestBuilding] = {\n            coords: buildingMap[connection.latestBuilding],\n            count: connection.count,\n            number: connection.latestBuilding\n          };\n        } else {\n          activeBuildings[connection.latestBuilding].count += 1;\n        }\n      }\n      // convert active Buildings into an array for simplicity in D3\n      graphData = [];\n      for (let building in activeBuildings) {\n        graphData.push(activeBuildings[building]);\n      }\n      console.log(\"graph data \",graphData)\n      // calculate the nw corner of a bounding box on the points\n      let bbox = { x: {}, y: {} };\n      // calculate the bounding box on the circles that are being drawn, decide on a max radius, and use it\n      for (let i = 0; i < graphData.length; i++) {\n        let d = graphData[i].coords;\n        if (d == undefined) {\n          console.log(\"missing coords\", d);\n          continue;\n        }\n        if (i == 0) {\n          // set minmax off the bat\n          bbox.x.min = bbox.x.max = d.lng;\n          bbox.y.min = bbox.y.max = d.lat;\n          continue;\n        }\n        if (d.lat > bbox.y.max) {\n          bbox.y.max = d.lat;\n        }\n        if (d.lat < bbox.y.min) {\n          bbox.y.min = d.lat;\n        }\n        if (d.lng > bbox.x.max) {\n          bbox.x.max = d.lng;\n        }\n        if (d.lng < bbox.x.min) {\n          bbox.x.min = d.lng;\n        }\n      }\n      // the northwest corner is the max.y and the min.x, and the south east corner is the min.y and the max.x\n      console.log(\"boundsbox is\", bbox);\n      bboxNWLatLng = new L.LatLng(bbox.y.max, bbox.x.min);\n      bboxSELatLng = new L.LatLng(bbox.y.min, bbox.x.max);\n      redraw()\n    }\n    let initialize = (userData) => {\n\n      // this is the width the svg should be to cover the full map\n      let bounds = mymap.getPixelBounds();\n      let width = bounds.max.x - bounds.min.x;\n      let height = bounds.max.y - bounds.min.y;\n      // create an svg\n      svg = d3.select(mymap.getPanes().overlayPane).append(\"svg\");\n      g = svg.append(\"g\").attr(\"class\", \"leaflet-zoom-hide\");\n      // define apply latlng to layer that takes in geopoints and produces screenspace x,y for drawing on svg\n      // NOTE that geojson points are going to have the x first in the coordinates\n      applyLatLngToLayer = function(d) {\n        // d is a lat lng calculated from the getCenter() method of a polyline\n        // do some comparison of building number to geojson of buildings to get coords\n        return mymap.latLngToLayerPoint(d);\n      };\n      // connect redraw to the map events\n      mymap.on(\"zoomend\", redraw);\n      mymap.on(\"moveend\", redraw);\n      //establish the circle scale before the data gets changed at all\n      let maxCount = Math.max(...userData.map(e=>e.count))\n      circleOpacityScale = d3\n        .scaleLinear()\n        .domain([1, maxCount])\n        .range([\"rgba(255,0,0,.1)\",\"rgba(255,0,0,1)\"])\n      //make a legend\n      legendSvg = d3.select(\"#legend\")\n      legendG = legendSvg.append(\"g\").attr(\"class\",\"legend\").attr(\"transform\",\"translate(10,20)\")\n      circleLegend = legend.legendColor()\n      .scale(circleOpacityScale)\n      .shape(\"circle\")\n      .shapePadding(20)\n      .labelOffset(20)\n      .orient(\"vertical\")\n      legendG.call(circleLegend)\n      d3.select(\"#legendHolder\").style(\"width\",legendG.node().getBoundingClientRect().width+\"px\")\n      legendSvg.attr(\"height\",(legendG.node().getBoundingClientRect().height + 20) +\"px\")\n\n    };\n    let unsubscribeDensity = mapData.subscribe(data => {\n      if(data.length == 0){\n        return\n      }\n      if (!once) {\n        initialize(data);\n        once = true\n      }\n      updateData(data)\n    });\n  });\n</script>\n\n<style>\n  main {\n    text-align: center;\n    padding: 1em;\n    max-width: 240px;\n    margin: 0 auto;\n  }\n  #leafletHolder {\n    width: 100%;\n  }\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  @media (min-width: 640px) {\n    main {\n      max-width: none;\n    }\n  }\n  #mapid {\n    height: 80vh;\n  }\n  #legendHolder {\n    position:absolute;\n    top:0px;\n    right:0px;\n    z-index:5000;\n    background:white;\n    border-radius:10px;\n    padding:5px;\n  }\n</style>\n\n<div id=\"leafletHolder\">\n  <div id=\"mapid\" />\n</div>\n<div id=\"legendHolder\">\n<p>People Connected</p>\n<svg id=\"legend\">\n</svg></div>",
    "<script>\n  export let name;\n  export let buildingJSON;\n  import { onMount } from \"svelte\";\n  import { wifiData } from \"./store.js\";\n  import * as d3 from \"d3\";\n  import legend from \"d3-svg-legend\"\n  onMount(async () => {\n    console.log(\"loaded\");\n    console.log(\"building Json is \", buildingJSON);\n    let mymap = L.map(\"mapid\").setView([32.231481, -110.951838], 18);\n    L.esri.basemapLayer(\"Gray\").addTo(mymap);\n    var subtleUA = L.esri\n      .tiledMapLayer({\n        url:\n          \"https://services.maps.arizona.edu/pdc/rest/services/SubtleCanvasTiles/MapServer\"\n      })\n      .addTo(mymap);\n    // this  is the magic line for converting the polygon data into useful values\n    /*\n      let point = new L.Point(centerL20[0],centerL20[1])\n      let pointLatLng = L.Projection.SphericalMercator.unproject(point)\n      */\n    // TODO think about preconfiguring the buildingJSON to be a map already just with coordinates and building numbers\n    let buildingMap = {};\n    for (let feature of buildingJSON.features) {\n      // recall that the coordinates are ordered x,y in geojson, so must put into conversion correctly\n      buildingMap[\n        feature.properties[\"Buildings.SpaceNumLetter\"]\n      ] = new L.LatLng(\n        feature.geometry.coordinates[1],\n        feature.geometry.coordinates[0]\n      );\n    }\n    console.log(\"building map is \",buildingMap)\n\n    // subscribe to the store\n    let once = false;\n    let graphData,\n      circleScale,\n      applyLatLngToLayer,\n      bboxNWLatLng,\n      legendSvg,\n      legendG,\n      legendEle,\n      bboxSELatLng,\n      svg,\n      maxRadius = 20,\n      g;\n    let redraw = function() {\n      // need a function to calculate the bounds of the points\n      console.log(\"redrawing\");\n      // occasionally when zooming and panning the svg's container move, so we have to set svg to be relative and move it left and right\n\n      // make a circle and append it to the svg, and then transform it with the results of the applylatlng\n      let circle = g\n        .selectAll(\".testPoints\")\n        .data(graphData, d => d.number)\n        .join(\n          enter =>\n            enter\n              .append(\"circle\")\n              .attr(\"r\", d => circleScale(d.duration))\n              .attr(\"class\", \"testPoints\")\n              .attr(\"transform\", d => {\n                if (d.coords == undefined) {\n                  console.log(\"missing coords on\", d);\n                } else {\n                  return `translate(${applyLatLngToLayer(d.coords).x},${\n                    applyLatLngToLayer(d.coords).y\n                  })`;\n                }\n              })\n              .attr(\"fill\", \"red\")\n              .attr(\"opacity\", 0.5),\n          update =>\n            update.attr(\"transform\", d => {\n              if (d.coords == undefined) {\n                console.log(\"missing coords on\", d);\n              } else {\n                return `translate(${applyLatLngToLayer(d.coords).x},${\n                  applyLatLngToLayer(d.coords).y\n                })`;\n              }\n            })\n            .attr(\"r\",d=> circleScale(d.duration)),\n          exit => exit.remove()\n        );\n      // the width is the diff nw and se bbox points\n      let screenNW = applyLatLngToLayer(bboxNWLatLng);\n      let screenSE = applyLatLngToLayer(bboxSELatLng);\n      // make sure the circles don't get cut off, so we add a radius on all edges of SVG\n      svg.attr(\"width\", screenSE.x - screenNW.x + 2 * maxRadius);\n      svg.attr(\"height\", screenSE.y - screenNW.y + 2 * maxRadius);\n      // get the pixel coordinates of the top left corner of bbox\n      // subtract some left so we don't cutt off the circles\n      svg.style(\"left\", screenNW.x - maxRadius + \"px\");\n      svg.style(\"top\", screenNW.y - maxRadius + \"px\");\n      // now update the g that is containing the circles\n      // add in the circle radius because points need to shift extra given the padded space\n      g.attr(\n        \"transform\",\n        `translate(${-screenNW.x + maxRadius},${-screenNW.y + maxRadius})`\n      );\n    };\n    let updateData = userData => {\n      //\n      console.log(\"running data\")\n      if (userData.length == 0) {\n        // just pick a graphData \n        graphData =[] \n        redraw()\n        return\n      }\n      let activeBuildings = {};\n      for (let connection of userData) {\n        if (activeBuildings[connection.apBuildingNumber] == undefined) {\n          activeBuildings[connection.apBuildingNumber] = {\n            coords: buildingMap[connection.apBuildingNumber],\n            duration: 1,\n            number: connection.apBuildingNumber\n          };\n        } else {\n          activeBuildings[connection.apBuildingNumber].duration += calculateTime(connection);\n        }\n      }\n      // convert active Buildings into an array for simplicity in D3\n      graphData = [];\n      for (let building in activeBuildings) {\n        graphData.push(activeBuildings[building]);\n      }\n      //get only the durations and establish domain\n      let durations = graphData.map(e=> e.duration)\n      circleScale.domain([Math.min(...durations),Math.max(...durations)]).range([5,maxRadius])\n\n      // update legend so values change\n      console.log(\"graph data \",graphData)\n      // calculate the nw corner of a bounding box on the points\n      let bbox = { x: {}, y: {} };\n      // calculate the bounding box on the circles that are being drawn, decide on a max radius, and use it\n      for (let i = 0; i < graphData.length; i++) {\n        let d = graphData[i].coords;\n        if (d == undefined) {\n          console.log(\"missing coords\", d);\n          continue;\n        }\n        if (i == 0) {\n          // set minmax off the bat\n          bbox.x.min = bbox.x.max = d.lng;\n          bbox.y.min = bbox.y.max = d.lat;\n          continue;\n        }\n        if (d.lat > bbox.y.max) {\n          bbox.y.max = d.lat;\n        }\n        if (d.lat < bbox.y.min) {\n          bbox.y.min = d.lat;\n        }\n        if (d.lng > bbox.x.max) {\n          bbox.x.max = d.lng;\n        }\n        if (d.lng < bbox.x.min) {\n          bbox.x.min = d.lng;\n        }\n      }\n      // the northwest corner is the max.y and the min.x, and the south east corner is the min.y and the max.x\n      console.log(\"boundsbox is\", bbox);\n      bboxNWLatLng = new L.LatLng(bbox.y.max, bbox.x.min);\n      bboxSELatLng = new L.LatLng(bbox.y.min, bbox.x.max);\n      redraw()\n    }\n    // this function lets us figure out the amount of time (in minutes) for a duration\n    let calculateTime = (d)=> {\n      // calculate in ms the data in niceDuration\n      let parts = d.niceDuration.split(\":\").map(e=> parseInt(e))\n\n      return parts[0]*60 + parts[1] + (parts[2]/60)\n    }\n    let initialize = (userData) => {\n\n      // this is the width the svg should be to cover the full map\n      let bounds = mymap.getPixelBounds();\n      let width = bounds.max.x - bounds.min.x;\n      let height = bounds.max.y - bounds.min.y;\n      // create an svg\n      svg = d3.select(mymap.getPanes().overlayPane).append(\"svg\");\n      g = svg.append(\"g\").attr(\"class\", \"leaflet-zoom-hide\");\n      // define apply latlng to layer that takes in geopoints and produces screenspace x,y for drawing on svg\n      // NOTE that geojson points are going to have the x first in the coordinates\n      applyLatLngToLayer = function(d) {\n        // d is a lat lng calculated from the getCenter() method of a polyline\n        // do some comparison of building number to geojson of buildings to get coords\n        return mymap.latLngToLayerPoint(d);\n      };\n      // connect redraw to the map events\n      mymap.on(\"zoomend\", redraw);\n      mymap.on(\"moveend\", redraw);\n      //establish the circle scale before the data gets changed at all\n      // decide circle scale is the sum of the amount of time spent in that location during the selected time\n      // separate by building \n      circleScale = d3\n        .scaleLinear()\n        .range([5, maxRadius]);\n      //legend setup\n      legendSvg = d3.select(\"#legend\")\n      legendG = legendSvg.append(\"g\").attr(\"transform\",\"translate(20,20)\")\n      legendEle = legend.legendSize()\n      .scale(circleScale)\n      .shape(\"circle\")\n      .labelOffset(20)\n      .shapePadding(10)\n      .orient(\"vertical\")\n      legendG.call(legendEle)\n      d3.select(\"#legendHolder\").style(\"width\",legendG.node().getBoundingClientRect().width + \"px\")\n      legendSvg.attr(\"height\",(legendG.node().getBoundingClientRect().height + 20 )+\"px\")\n      legendSvg.attr(\"width\",(legendG.node().getBoundingClientRect().width + 20 )+\"px\")\n      // attempt to style the created legend correctly\n      d3.selectAll(\".swatch\").attr(\"fill\",\"red\").attr(\"opacity\",.5)\n    };\n    let unsubscribeWifiData = wifiData.subscribe(data => {\n      if (!once) {\n        initialize(data);\n        once = true\n      }\n      if(data.type != undefined) {\n        console.log(\"brush trigger data change\",data.type)\n        updateData(data.data)\n      } else {\n      updateData(data)\n      }\n    });\n  });\n</script>\n\n<style>\n  main {\n    text-align: center;\n    padding: 1em;\n    max-width: 240px;\n    margin: 0 auto;\n  }\n  #leafletHolder {\n    width: 100%;\n  }\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  @media (min-width: 640px) {\n    main {\n      max-width: none;\n    }\n  }\n  #mapid {\n    height: 80vh;\n  }\n  #legendHolder {\n    position:absolute;\n    top:0px;\n    right:0px;\n    background:white;\n    border-radius:10px;\n    padding:10px;\n    z-index:5000;\n  }\n</style>\n\n<div id=\"leafletHolder\">\n  <div id=\"mapid\" />\n</div>\n<div id=\"legendHolder\">\n<p>Radius in minutes</p>\n<svg id=\"legend\">\n</svg></div>",
    "<script>\nimport {histogram} from \"./histPopout.js\"\nimport {mapData} from \"./store.js\"\nexport let building,headCount,number,screen\n\n\nlet holder,svg,xIcon\nimport {onMount} from \"svelte\"\nonMount(()=> {\n    holder.style.left = screen.x + \"px\"\n    holder.style.top = screen.y + \"px\"\n    holder.style.width = svg.getBoundingClientRect().width + \"px\"\n    // create the histogram\n    histogram(svg,number,{width:svg.getBoundingClientRect().width,height:svg.getBoundingClientRect().height,margin:40})\n    // potential mem leak if too many popouts made and closed without unsubscribing\n    mapData.subscribe(data=> {\n        // find the building for this popout and updatethe headcount\n        if (data!=null) {\n\n        for(let d of data) {\n            if (d.latestBuilding == number) {\n                console.log(\"changed building\",number,headCount, \"to\",d.count)\n                headCount = d.count\n            }\n        }\n        }\n    })\n\n})\n\nlet removePopout = ()=> {\n    holder.remove()\n}\n</script>\n\n<style>\n#popoutHolder {\n    position:absolute;\n    background:white;\n    border-radius:10px;\n    z-index:2000;\n}\n#top {\n    display:flex;\n    justify-content: space-between;\n}\n#exit {\n}\n\n</style>\n\n<div id=\"popoutHolder\" bind:this={holder}>\n<div id=\"top\">\n<div id=\"text\">\n<p>Building: {building}</p>\n<p>HeadCount: {headCount}</p>\n</div>\n<div id=\"exitHolder\">\n<img src=\"x.png\" alt=\"\" id=\"exit\" on:click={removePopout} bind:this={xIcon}>\n</div>\n</div>\n<svg id=\"histogram\" bind:this={svg}></svg>\n</div>",
    "<script>\n  export let imgSrc, title, summaryText;\n  import {onMount} from \"svelte\"\n  let imgElement\n  let holder\n  onMount(()=> {\n      // move the image into the top corner of the half\n      let holderRect = holder.getBoundingClientRect()\n    imgElement.style.position=\"absolute\"\n    imgElement.style.top = holderRect.top+\"px\"\n    imgElement.style.left = holderRect.left + \"px\"\n\n  })\n</script>\n\n<style>\n* {\n    z-index: 5;\n}\n#optionHolder {\n    height:100%;\n}\n#optionHolder img {\n    z-index: 1;\n}\n.text {\n    background:#183055;\n    color:white;\n    box-shadow: 0 7px 23px 0 rgba(32, 44, 62, 0.68);\n    border-radius: 10px;\n    margin:5%;\n}\n#title {\n    padding: 2%;\n}\n#summary{\n    text-align:center;\n}\n#content {\n    display:flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items:center;\n    height:70%;\n    width:80%;\n    margin:0 auto;\n\n}\n</style>\n\n\n<div id=\"optionHolder\" bind:this={holder}>\n  <img bind:this={imgElement} src={imgSrc} alt=\"\" id=\"backgroundimage\" />\n  <div id=\"content\">\n  <div id=\"title\" class=\"text\">\n    <h3>{title}</h3>\n  </div>\n  <div id=\"summary\" class=\"text\">\n    <p>{summaryText}</p>\n  </div>\n  </div>\n</div>\n",
    "<script>\n  import { allDevices } from \"./store.js\";\n  import { onMount } from \"svelte\";\n  import CB from \"./checkBox.svelte\";\n  let holder;\n  onMount(() => {\n    console.log(\"holder is\", holder);\n    let once = false\n    allDevices.subscribe(lst => {\n      if (!once) {\n        // generate a check box element for each\n        for (let device in lst) {\n          new CB({\n            target: holder,\n            props: {\n                Content:device\n            }\n          });\n        }\n        once =true\n      }\n    });\n  });\n</script>\n<style>\n#checkBoxHolder{\n    display:flex;\n}\n</style>\n<div id=\"checkBoxHolder\" bind:this={holder} />\n",
    "<script>\nimport Map from \"./DensityMap.svelte\"\nimport Brushable from \"./brushableDensity.svelte\"\nimport {buildingJSON} from \"./data.js\"\n// setup the store with the data for this application\n\nlet dims ={\n  width:window.innerWidth,\n  height:100,\n  margin:20\n}\n</script>\n\n<style>\n#secondVisHolder {\n  display:flex;\n  flex-direction: column;\n  height:100%;\n  width:100%;\n\n}\n#bottomViews {\n  display:flex;\n\n}\n</style>\n\n<div id=\"secondVisHolder\">\n<Map buildingJSON={buildingJSON}></Map>\n<div id=\"lower\">\n<Brushable dims={dims}></Brushable>\n</div>\n</div>",
    "<script>\n  export let name;\n  import VidOverlay from \"./overlayVid.svelte\";\n  import * as d3 from \"d3\";\n  import Gant from \"./gant_chart.svelte\";\n  import { onMount } from \"svelte\";\n  onMount(async () => {\n    let paulData = await fetch(\"paulFebruaryTokenized.csv\").then(res =>\n      res.text()\n    );\n    console.log(paulData);\n    let buildingNameData = await fetch(\"building_names.csv\").then(res =>\n      res.text()\n    );\n    let dsv = d3.dsvFormat(\",\");\n    paulData = dsv.parse(paulData);\n    buildingNameData = dsv.parse(buildingNameData);\n    console.log(paulData, buildingNameData);\n    const graph = new Gant({\n      target: document.body,\n      props: {\n        data: paulData,\n        buildingData: buildingNameData\n      }\n    });\n  });\n</script>\n\n<style>\n  main {\n    text-align: center;\n    padding: 1em;\n    max-width: 240px;\n    margin: 0 auto;\n  }\n\n  h1 {\n    color: #ff3e00;\n    text-transform: uppercase;\n    font-size: 4em;\n    font-weight: 100;\n  }\n\n  @media (min-width: 640px) {\n    main {\n      max-width: none;\n    }\n  }\n\n</style>\n\n<VidOverlay />\n\n<div id=\"tooltipHolder\">\n  <p id=\"tipText\" />\n</div>\n<div id=\"graphs\">\n  <div id=\"topaxisholder\">\n    <svg id=\"topaxis\" />\n  </div>\n  <div id=\"topgraph\">\n    <svg id=\"main\" />\n  </div>\n  <div id=\"bottomgraph\">\n    <svg id=\"brushable\" />\n  </div>\n</div>\n",
    "<script>\nimport Map from \"./Map.svelte\"\nimport Brushable from \"./brushableIndividual.svelte\"\nimport Selectors from \"./dataSelectors.svelte\"\nimport {buildingJSON} from \"./data.js\"\nimport {wifiData } from \"./store.js\"\n// setup the store with the data for this application\n\nlet dims ={\n  width:window.innerWidth*.8,\n  height:100,\n  margin:20\n}\n</script>\n\n<style>\n#secondVisHolder {\n  display:flex;\n  flex-direction: column;\n  height:100%;\n  width:100%;\n\n}\n#bottomViews {\n  display:flex;\n\n}\n</style>\n\n<div id=\"secondVisHolder\">\n<Map buildingJSON={buildingJSON}></Map>\n<div id=\"bottomViews\">\n<Brushable dims={dims}></Brushable>\n<Selectors></Selectors>\n</div>\n</div>",
    "<style>\n  #innerholder {\n    position: relative;\n    top: -50%;\n    left: -50%;\n    background: white;\n    border-radius: 6px;\n  }\n  #vidholder {\n      z-index: 5000;\n      position:absolute;\n      top:25%;\n      left:50%;\n  }\n#overlay {\n    position:fixed;\n    top:0px;\n    left:0px;\n    height:100%;\n    width:100%;\n    background:rgba(100,100,100,.7);\n}\nvideo{\n    width:750px;\n}\n\n</style>\n\n<div id=\"vidholder\">\n    <div id=\"overlay\" />\n  <div id=\"innerholder\">\n    <video src=\"explanation.webm\" id=\"intro\" autoplay controls />\n    <div\n      id=\"close\"\n      on:click={() => {\n        document.querySelector('#vidholder').remove();\n      }}>\n      <h2>Close</h2>\n    </div>\n  </div>\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}